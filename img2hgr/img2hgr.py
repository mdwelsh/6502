#!/usr/bin/env python

import argparse
import math
import sys

from PIL import Image


BYTES_PER_COL = 8


def screen_pos_to_mem_offset(x: int, y: int) -> int:
    """Calculate the memory offset in the 8192-byte HGR page for the screen
    pixel at coordinate (x, y), where 0 <= x < 280 and 0 <= y < 192.
    """
    # The Apple II HGR page is laid out as follows. The full page size is 8192 bytes.
    # It is divided into 64 "chunks" of 128 bytes each. The chunks are grouped
    # into "blocks", each block consisting of 8 chunks. There are 8 blocks total.
    #
    # First 40 bytes are line 0 of screen, with each byte containing 7 pixels (40*7 = 280).
    # Next 40 bytes are line 63.
    # Next 40 bytes are line 127.
    # Then: 8 unused bytes.
    #
    # The second chunk corresponds to lines 8, 71, and 135.
    # And so forth for the first 8 chunks.
    #
    # Then, the second block begins, with its first chunk corresponding to rows
    # 1, 64, 128.
    # 
    # Block 0:
    #   Chunk 0 (40, 40, 40, 8): lines 0, 63, 127.
    #   Chunk 1 (40, 40, 40, 8): lines 8, 71, 135.
    #   Chunk 2 (40, 40, 40, 8): lines 16, 79, 143.
    #   Chunk 3 (40, 40, 40, 8): lines 24, 87, 151.
    #   Chunk 4 (40, 40, 40, 8): lines 32, 95, 159.
    #   Chunk 5 (40, 40, 40, 8): lines 40, 103, 167.
    #   Chunk 6 (40, 40, 40, 8): lines 48, 111, 175.
    #   Chunk 7 (40, 40, 40, 8): lines 56, 119, 183.
    #
    # Block 1:
    #   Chunk 8 (40, 40, 40, 8): lines 1, 64, 128.
    #   Chunk 9 (40, 40, 40, 8): lines 9, 72, 136.
    #   ...
    #   Chunk 15 (40, 40, 40, 8): lines 57, 120, 184.
    #
    # ...
    # Block 7:
    #   Chunk 56 (40, 40, 40, 8): lines 7, 70, 134.
    #   ...
    #   Chunk 63 (40, 40, 40, 8): lines 62, 126, 191.

    assert 0 <= x < 280
    assert 0 <= y < 192

    # Calculate a lookup table from row number to byte offset.
    # This is being rather lazy as I'm sure I could calculate it
    # directly, but this is easier for me to wrap my head around.
    row_to_byte_offset = {}
    row = 0
    row = 0
    for byte_offset in [0, 40, 80]:
        for chunk_in_block in range(8):
            for block in range(8):
                row_to_byte_offset[row] = (block * 1024) + (chunk_in_block * 128) + byte_offset
                row += 1

    # Determine the byte to update within the row.
    x_offset = int(x / 7)
    return row_to_byte_offset[y] + x_offset


def process_image(
    infile: str, outfile: str, name: str, width: int, height: int, outbin: bool
):
    """Process the image stored in infile, writing the result to outfile."""

    img = Image.open(infile)
    img = img.convert("RGB")
    img = img.resize((width, height), resample=Image.NEAREST)
    in_pixels = iter(list(img.getdata()))
    out_pixels = bytearray(8192)  # This is always the size of an HGR page.

    out_pixel = 0
    shift = 7
    for in_y in range(height):
        for in_x in range(width):
            in_pixel = next(in_pixels)
            r, g, b = in_pixel

            # A simple threshold for now.
            if r >= 128 or g >= 128 or b >= 128:
                # Apple II screen pixels are big-endian.
                #out_pixel = out_pixel | (1 << shift - 1)
                out_pixel = out_pixel | (1 << (7 - shift))

            shift = shift - 1
            if shift == 0:
                # Finished with output pixel.
                mem_offset = screen_pos_to_mem_offset(in_x - 6, in_y)
                out_pixels[mem_offset] = out_pixel & 0xFF
                out_pixel = 0
                shift = 7

    if outbin:
        # Output binary.
        with open(outfile, "wb+") as outf:
            outf.write(out_pixels)
        print(f"Saved binary to {outfile}")
    else:
        # Output assembly source.
        with open(outfile, "w+") as outf:
            outf.write(
                f"; Generated by img2hgr.py --name {name} --width {width} "
                f"--height {height} {infile} {outfile}\n"
            )
            outf.write(f"{name}:\n")
            col = 0
            for out_pixel in out_pixels:
                if col == 0:
                    outf.write("  .byte ")
                outf.write(f"${curpixel:02x}")
                col += 1
                if col < BYTES_PER_COL:
                    outf.write(",")
                else:
                    outf.write("\n")
                    col = 0
            outf.write("\n")
        print(f"Saved assembly to {outfile}")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--name", type=str, default="imgdata")
    parser.add_argument("--width", type=int, default=280)
    parser.add_argument("--height", type=int, default=192)
    parser.add_argument("--bin", type=bool, default=True)
    parser.add_argument("infile")
    parser.add_argument("outfile")
    args = parser.parse_args()

    process_image(
        args.infile,
        args.outfile,
        args.name,
        args.width,
        args.height,
        args.bin,
    )


if __name__ == "__main__":
    main()
